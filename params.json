{"name":"Justconfig","tagline":"The Justconfig library provides easy access to configuration properties using interface proxy instances","body":"# The Justconfig library\r\n\r\nThe Justconfig library provides easy access to configuration properties. By simply specifying an interface describing your configuration values you can access those values without a hassle, independent of their source.  \r\nJustconfig has no dependencies.\r\nCheck out the examples!\r\n\r\n\r\n## Simple Example\r\nThis example showcases a simple usage, leveraging annotation interfaces' ability to specify default values with method declaration\r\n\r\n\r\n```\r\n#!java\r\npublic class Simple  {\t\r\n\tprivate static @interface ConfigSpecs {\r\n\t\tint poolSize() default 16;\r\n\t\tString threadGroupName() default \"myexecs\";\r\n\t}\r\n\tprivate static final ConfigSpecs CONFIG = ConfigurationProxyBuilder.newBuilder(new SystemPropertiesConfigurationSource())\r\n\t\t\t\t\t\t\t\t\t\t\t\t.build(ConfigSpecs.class);\r\n\t\r\n\t\r\n    public static void main( String[] args ) throws InstantiationException, IllegalAccessException{\r\n    \tSystem.setProperty(\"threadGroupName\", \"configuredValue\");\r\n    \tassertEquals(16, CONFIG.poolSize());\r\n    \tassertEquals(\"configuredValue\", CONFIG.threadGroupName());\r\n    }\r\n\r\n\tprivate static void assertEquals(Object one, Object two) {\r\n\t\tif(one != two && !one.equals(two)) {\r\n\t\t\tthrow new IllegalArgumentException(one+\" != \"+two);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## More information\r\nThere are a few, very simple, core concepts in Justconfig:  \r\n\r\n* Configuration Sources\r\n* Configuration Spec\r\n* Value Reader Service\r\n* Strategies\r\n    1. DefaultValueStrategy - Resolves a default value for a property accessor\r\n    2. PropertyNameStrategy - Resolves the proprety name for a property accessor\r\n    3. PropertyTypeStrategy - Resolves the property type for a property accessor\r\n    4. ValueReaderResolverStrategy - Resolves the ValueReaderService for a type\r\n\r\n### Configuration Sources\r\nA Configuration source retrieves simple values (Strings or primitives) for a String configuration property name. A simpler subset of [Apache Configuration](http://commons.apache.org/configuration/) API's [Configuration](http://commons.apache.org/configuration/apidocs/org/apache/commons/configuration/Configuration.html) interface.  \r\nJustconfig comes out of the box with these configuration sources:  \r\n\r\n* System Properties  \r\n* java.util.Properties  \r\n* Apache Configuration (optional dependency)\r\n\r\nDelegation of configuration sources can be achieved with the ConfigurationSourceChain class.\r\n\r\nNew Configuration sources can be easily added by implementing the ConfigurationSource interface or extending the ConfigurationSourceBase class which helps with String backed configuration sources.\r\n\r\n### Configuration Spec\r\nConfiguration spec is your definition of what the configuration holds, defined by an interface or an annotation such as the following:\r\n\r\n```\r\n#!java\r\npublic @interface ConfigSpecs {\r\n\tint poolSize() default 16;\r\n\tString threadGroupName();\r\n}\r\npublic interface ConfigSpecs2 {\r\n\tBoolean poolSize();\r\n\tString threadGroupName();\r\n}\r\n```\r\nJustconfig will create a proxy instance of the interface for you to use, working just like how you think it will.  \r\n\r\nIf you're wondering why pick or not pick annotations over interfaces, these are the key differences:  \r\n\r\n* Annotations let you specify default values in an convenient way  \r\n* Annotations' methods' return types are limited to Strings, Enums, Classes and (not boxed) primitives. This also means all primitive values must either be explicitly set (in the configuration source) or a default value must be given (In the Configuration Spec) or a NullPointerException will be thrown on access to indicate the missing value  \r\n* Annotaions unlike interface can't extends other annotations/interfaces.\r\n\r\n\r\n### Value Reader Services\r\nWhile the return types for methods in annotations are from a constant set, interfaces can have other return values.  \r\nThis is where Value Reader Services come in to play, an implementation accepts certain types that it can obtain from a configuration, and does so when such a value is requested.\r\n\r\nLook at EnumValueReaderService for a simple example:\r\n```\r\n#!java\r\npublic class EnumValueReaderService implements ValueReaderService {\r\n\r\n\t/**\r\n\t * return true iff the type is an enum.\r\n\t */\r\n\tpublic boolean readable(Class<?> type) {\r\n\t\treturn Enum.class.isAssignableFrom(type);\r\n\t}\r\n\r\n\t/**\r\n\t * Reads an enum constant using the enum's valueOf method\r\n\t */\r\n\t@SuppressWarnings({ \"unchecked\" })\r\n\tpublic Enum readValue(ClassLoader loader, ConfigurationSource config,\r\n\t\t\tString name, Class<?> type)\r\n\t\t\tthrows IllegalArgumentException {\r\n\t\tString enumName = config.getString(name);\r\n\t\tif(enumName == null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tClass<? extends Enum> eClass = type.asSubclass(Enum.class);\r\n\t\treturn Enum.valueOf(eClass, enumName);\r\n\t}\r\n}\r\n```\r\nJustconfig by default looks for ValueReaderServices using Java's [ServiceLoader](http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html), allowing you to easily implement value readers for more types or plug in libraries that do.","google":"UA-38567300-1","note":"Don't delete this file! It's used internally to help with page regeneration."}